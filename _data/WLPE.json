{"WLPE.csv":[{"venue":"WLPE","id":"b38d621a72ff5d57f9fbfdc0482c7897f81a3eb5","venue_1":"WLPE","year":"2003","title":"Hasta-La-Vista: Termination Analyser for Logic Programs","authors":"Alexander Serebrenik, Danny De Schreye","author_ids":"1747171, 1714620","abstract":"Verifying termination is often considered as one of the most important aspects of program verification. Logic languages, allowing us to program declaratively , increase the danger of non-termination. Therefore, termination analysis received considerable attention in logic programming (see e.g. [7, 8, 10, 16]). Unfortunately, the majority of existing termination analysers, such as Termi-Log [15], TerminWeb [7], and cTI [16] are restricted to pure logic programs and thus, leave many interesting real-world examples out of consideration. Therefore , in order to abridge the gap between programming practice and existing termination analysers real-world programming techniques should be considered. In this paper we present Hasta-La-Vista—a powerful tool for analysing termination of logic programs with integer computations. Hasta-La-Vista extends the constraints-based approach of Decorte et al. [9] by integrating the inference algorithm of [19]. Moreover, as explained in [19], in the integer case our approach is not limited to proving termination, but can also infer termination, i.e., find the set of queries terminating for a given program. System architecture. Conceptually, Hasta-La-Vista consists of three main parts: transformation, constraints generation and constraints solving. As a preliminary step, given a program and a set of atomic queries, type analysis of Janssens and Bruynooghe [14] computes the call set. We opted for a very simple type inference technique that provides us only with information whether some argument is integer or not. Based on the results of the type analysis the system decides whether termination of the given program can be dependent on the integer computation. In this case, the adorning transformation is applied [19]. The aim of the transformation is to discover bounded integer arguments and to make the bounds explicit. Intuitively, if a variable x is known to be bounded from above by n, then n x is always positive and thus, can be used as a basis for a definition of a level-mapping (a function from the set of atoms to the naturals). In order to prove termination we have to show that the level-mapping decreases while traversing a clause. This requirement can be translated into a set of constraints. Finally, this set of constraints is solved and depending on the solution termination is 1","cites":"8","conferencePercentile":"50"},{"venue":"WLPE","id":"9d30c5e98325ab8c343b2deedc217c72280ebe6d","venue_1":"WLPE","year":"2002","title":"Enhancing Usefulness of Declarative Programming Frameworks through Complete Integration","authors":"Göran Falkman, Olof Torgersson","author_ids":"1701449, 1679770","abstract":"The Gisela framework for declarative programming was developed with the specific aim of providing a tool that would be useful for knowledge representation and reasoning within real-world applications. To achieve this, a complete integration into an object-oriented application development environment was used. The framework and methodology developed provide two alternative application programming interfaces (apis): Programming using objects or programming using a traditional equational declarative style. In addition to providing complete integration , Gisela also allows extensions and modifications due to the general computation model and well-defined apis. We give a brief overview of the declarative model underlying Gisela and we present the methodology proposed for building applications together with some real examples.","cites":"1","conferencePercentile":"16.66666667"}]}