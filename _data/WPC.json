{"WPC.csv":[{"venue":"WPC","id":"29f79792db4b15bfda7159d231034a24c593fa3f","venue_1":"WPC","year":"1996","title":"Fast, Flexible Syntactic Pattern Matching and Processing","authors":"William G. Griswold, Darren C. Atkinson, Collin McCurdy","author_ids":"6980007, 1722298, 2959124","abstract":"use of this material is permitted. However, permission to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works, must be obtained from the IEEE. Abstract Program understanding can be assisted by tools that match patterns in the program source. Lexical pattern matchers provide excellent performance and ease of use, but have a limited vocabulary. Syntactic matchers provide more precision, but may sacrifice performance, retargetability, ease of use, or generality. To achieve more of the benefits of both models, we extend the pattern syntax of AWK to support matching of abstract syntax trees, as demonstrated in a tool called TAWK. Its pattern syntax is language-independent, based on abstract tree patterns. As in AWK, patterns can have associated actions, which in TAWK are written in C for generality, familiarity, and performance. The use of C is simplified by high-level libraries and dynamic linking. To allow processing of program files containing non-syntactic constructs, mechanisms have been designed that allow transparent matching in a syntactic fashion. So far, TAWK has been retargeted to the MUMPS and C programming languages. We survey and apply prototypical approaches to concretely demonstrate the tradeoffs. Our results indicate that TAWK can be used to quickly and easily perform a variety of common software engineering tasks, and the extensions to accommodate non-syntactic features significantly extend the generality of syntactic matchers.","cites":"50","conferencePercentile":"80"},{"venue":"WPC","id":"e35ddd4d19d64c6d3435e60815014aa0ffb39419","venue_1":"WPC","year":"1996","title":"The Gadfly: An Approach to Architectural-Level System Comprehension","authors":"Kurt C. Wallnau, Paul C. Clements, Edwin J. Morris, Robert Krut","author_ids":"1741041, 1734918, 1727318, 2687735","abstract":"Technology to support system comprehension tends to reflect either a \" bottom-up \" or \" top-down \" approach. Bottom up approaches attempt to derive system models from source code, while top-down approaches attempt to map abstract \" domain \" concepts to concrete system artifacts. While both approaches have merit in theory, in practice the top-down approach has not yielded scalable, cost-effective technology. One problem with the top-down approach is that it is very expensive to develop domain models, and it is difficult to develop models that are sufficiently general to be applied to multiple systems (and hence amortize the development cost). This paper describes the Gadfly, an approach for developing narrowly-focused, reusable domain models that can be integrated and (re)used to aid in the process of top-down system comprehension.","cites":"8","conferencePercentile":"55"},{"venue":"WPC","id":"197e38e1a84a4a097bcd73cdc282bc5fb04ac4e0","venue_1":"WPC","year":"1996","title":"A Method for The Formal Testing of Program Visualization Tools","authors":"T. C. Nicholas Graham","author_ids":"4977083","abstract":"Many modern tools support program understanding through the visualization of program structure. Such tools are typically based on a formal theory describing the structure of programs to be visualized, such as first order logic [10, 13], temporal logic [6, 12], entity-relationship models [1, 14] and graph grammars [9, 4]. Two questions arise with such approaches: (a) does the tool correctly abide by the rules of the formalism, and (b) is the formalization itself correct? To address these questions in the context of the visual Clock-Works programming environment, we have developed a method for formally testing both the tool and the theory. This work relies heavily on the use of the PVS [3] theorem prover. Many of the proofs carried out in this work are easy to prove mechanically, but would be far too tedious to carry out by hand. While this technique was carried out in the context of the ClockWorks tool, the method should be applicable to any visualization system that can be formalized using logic.","cites":"0","conferencePercentile":"15"},{"venue":"WPC","id":"dc058bd00ab245d7c0b87b0e39211d7918175888","venue_1":"WPC","year":"1997","title":"Cognitive Design Elements to Support the Construction of a Mental Model during Software Visualization","authors":"Margaret-Anne D. Storey, F. David Fracchia, Hausi A. MÃ¼ller","author_ids":"1734938, 2646038, 1747880","abstract":"The scope of software visualization tools which exist for the navigation, analysis and presentation of software information varies widely. One class of tools, which we refer to as software exploration tools, provide graphical representations of software structures linked to textual views of the program source code and documentation. This paper describes a hierarchy of cognitive issues which should be considered during the design of a software exploration tool. The hierarchy of cognitive design elements is derived through the examination of program comprehension cognitive models. Examples of how existing tools address each of these issues are provided.","cites":"67","conferencePercentile":"100"}]}