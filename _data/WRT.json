{"WRT.csv":[{"venue":"WRT","id":"83e1c82163018d0460a92b33949819d555609306","venue_1":"WRT","year":"2007","title":"Improving Method Extraction: A Novel Approach to Data Flow Analysis Using Boolean Flags and Expressions","authors":"Nicolas Juillerat, Béat Hirsbrunner","author_ids":"2967744, 2760106","abstract":"1. Motivation Method extraction is a complex refactoring: it has to transform statements of source code and preserve semantics. While many recent development environments provide a semi-automated implementation of this refactoring, most of them are still flawed. The part of the process we want to discuss is the so called data flow analysis. Its purpose is to determine the arguments and the results of the method to extract. Various approaches to this problem have been proposed: graph based, scripting languages, and direct analyses. Graph-based approaches [1] are the most widely spread techniques. The problem with graph-based approaches is that the construction of the graph itself from the source code is difficult: the common representation of statements is not a graph, but the Abstract Syntax Tree (AST). While these approaches have shown to be good for analyses, their use in transformation is usually limited to the class graph which does not model statements. Their use for method extraction is hence limited. Scripting languages [2] have been used to express program transformations in a way that is simpler than an implementation in a language such as Java. While they can provide a high-level and simple description of various refactorings, these languages are hiding the actual implementation, for which they do not provide any help. A look on the source code of Eclipse revealed that the implementation of method extraction was neither based on graphs, nor on scripting languages. It is just a \" plain \" implementation based on the AST. Why does Eclipse use a \" plain \" implementation when high level formalisms are available? We give a partial answer to this question, by proposing a novel and simpler formalism for the problem of data flow analysis. Our approach differs from previous work in two aspects. First, it only uses very simple data structures and algorithms: tables of flags and boolean expressions. Second, it is based on the common representation of the source code: the AST. The idea behind our approach is to maintain, for each local variable, a table of boolean flags. Each flag captures some information about the variable, which is potentially relevant to identify arguments and results. More precisely, we define four facts and three regions, yielding 12 different flags per variable. The four facts are: whether the variable is read (R), whether it is always written (W), whether it is conditionally written (w), and whether it is \" …","cites":"1","conferencePercentile":"32.14285714"}]}