{"WebApps.csv":[{"venue":"WebApps","id":"24ef17aba402405b74cccadfb85dcae9e07cdb96","venue_1":"WebApps","year":"2011","title":"BenchLab: An Open Testbed for Realistic Benchmarking of Web Applications","authors":"Emmanuel Cecchet, Veena Udayabhanu, Timothy Wood, Prashant J. Shenoy","author_ids":"2367325, 2367189, 1696812, 1705052","abstract":"Web applications have evolved from serving static content to dynamically generating Web pages. Web 2.0 applications include JavaScript and AJAX technologies that manage increasingly complex interactions between the client and the Web server. Traditional benchmarks rely on browser emulators that mimic the basic network functionality of real Web browsers but cannot emulate the more complex interactions. Moreover, experiments are typically conducted on LANs, which fail to capture real latencies perceived by users geographically distributed on the Internet. To address these issues, we propose BenchLab, an open testbed that uses real Web browsers to measure the performance of Web applications. We show why using real browsers is important for benchmarking modern Web applications such as Wikibooks and demonstrate geographically distributed load injection for modern Web applications.","cites":"14","conferencePercentile":"68.18181818"},{"venue":"WebApps","id":"35b0d3fe937571eaf29f1473a919d397ba7141ac","venue_1":"WebApps","year":"2010","title":"xJS: Practical XSS Prevention for Web Application Development","authors":"Elias Athanasopoulos, Vasilis Pappas, Antonis Krithinakis, Spyros Ligouras, Evangelos P. Markatos, Thomas Karagiannis","author_ids":"1729961, 1764102, 1934517, 3347829, 1723275, 1763690","abstract":"We present xJS, a practical framework for preventing code-injections in the web environment and thus assisting for the development of XSS-free web applications. xJS aims on being fast, developer-friendly and providing backwards compatibility. We implement and evaluate our solution in three leading web browsers and in the Apache web server. We show that our framework can successfully prevent all 1,380 real-world attacks that were collected from a well-known XSS attack repository. Furthermore, our framework imposes negligible computational overhead in both the server and the client side, and has no negative side-effects in the overall user's browsing experience.","cites":"13","conferencePercentile":"64.28571429"},{"venue":"WebApps","id":"c01b0314e512edf4ebb922b14500789c46847eed","venue_1":"WebApps","year":"2011","title":"The Effectiveness of Application Permissions","authors":"Adrienne Porter Felt, Kate Greenwood, David Wagner","author_ids":"2838694, 3281020, 4073051","abstract":"Traditional user-based permission systems assign the user's full privileges to all applications. Modern platforms are transitioning to a new model, in which each application has a different set of permissions based on its requirements. Application permissions offer several advantages over traditional user-based permissions, but these benefits rely on the assumption that applications generally require less than full privileges. We explore whether that assumption is realistic, which provides insight into the value of application permissions. We perform case studies on two platforms with application permissions, the Google Chrome extension system and the Android OS. We collect the permission requirements of a large set of Google Chrome extensions and Android applications. From this data, we evaluate whether application permissions are effective at protecting users. Our results indicate that application permissions can have a positive impact on system security when applications' permission requirements are declared up-front by the developer, but can be improved.","cites":"77","conferencePercentile":"100"},{"venue":"WebApps","id":"beeb3990ffc3767b23e12e9e63245c5991cac028","venue_1":"WebApps","year":"2010","title":"DBTaint: Cross-Application Information Flow Tracking via Databases","authors":"Benjamin Davis, Hao Chen","author_ids":"2405691, 1721849","abstract":"Information flow tracking has been an effective approach for identifying malicious input and detecting software vulnerabilities. However, most current schemes can only track data within a single application. This single-application approach means that the program must consider data from other programs as either all tainted or all untainted, inevitably causing false positives or false negatives. These schemes are insufficient for most Web services because these services include multiple applications , such as a Web application and a database application. Although system-wide information flow tracking is available, these approaches are expensive and overkill for tracking data between Web applications and databases because they fail to take advantage of database semantics. We have designed DBTaint, which provides information flow tracking in databases to enable cross-application information flow tracking. In DBTaint, we extend database datatypes to maintain and propagate taint bits on each value. We integrate Web application and database taint tracking engines by modifying the database interface, providing cross-application information flow tracking transparently to the Web application. We present two prototype implementations for Perl and Java Web services, and evaluate their effectiveness on two real-world Web applications, an enterprise-grade application written in Perl and a robust forum application written in Java. By taking advantage of the semantics of database operations, DBTaint has low overhead: our un-optimized prototype incurs less than 10-15% overhead in our benchmarks.","cites":"22","conferencePercentile":"85.71428571"},{"venue":"WebApps","id":"a52b1d763d0ed497c79b2a67b0f48c74ef13594d","venue_1":"WebApps","year":"2011","title":"C3: An Experimental, Extensible, Reconfigurable Platform for HTML-based Applications","authors":"Benjamin S. Lerner, Brian Burg, Herman Venter, Wolfram Schulte","author_ids":"1705058, 1687998, 3044885, 1695183","abstract":"The common conception of a (client-side) web application is some collection of HTML, CSS and JavaScript (JS) that is hosted within a web browser and that interacts with the user in some non-trivial ways. The common conception of a web browser is a monolithic program that can render HTML, execute JS, and gives the user a portal to navigate the web. Both of these are misconceptions: nothing inherently confines webapps to a browser's page-navigation idiom, and browsers can do far more than merely render content. Indeed, browsers and web apps are converging in functionality, but their underlying technologies are so far largely distinct. We present C3, an implementation of the HTML/CSS/JS platform designed for web-client research and experimentation. C3's typesafe, modular architecture lowers the barrier to webapp and browser research. Additionally, C3 explores the role of extensibil-ity throughout the web platform for customization and research efforts, by introducing novel extension points and generalizing existing ones. We discuss and evaluate C3's design choices for flexibility, and provide examples of various extensions that we and others have built.","cites":"6","conferencePercentile":"27.27272727"},{"venue":"WebApps","id":"5878301fb9bcd3e6ca30e644670955bf07696607","venue_1":"WebApps","year":"2010","title":"JSMeter: Comparing the Behavior of JavaScript Benchmarks with Real Web Applications","authors":"Paruj Ratanaworabhan, Benjamin Livshits, Benjamin G. Zorn","author_ids":"2283341, 7494454, 1762643","abstract":"JavaScript is widely used in web-based applications and is increasingly popular with developers. So-called browser wars in recent years have focused on JavaScript performance, specifically claiming comparative results based on benchmark suites such as SunSpider and V8. In this paper we evaluate the behavior of JavaScript web applications from commercial web sites and compare this behavior with the benchmarks. We measure two specific areas of JavaScript runtime behavior: 1) functions and code and 2) events and handlers. We find that the benchmarks are not representative of many real web sites and that conclusions reached from measuring the benchmarks may be misleading. Specific common behaviors of real web sites that are underem-phasized in the benchmarks include event-driven execution , instruction mix similarity, cold-code dominance, and the prevalence of short functions. We hope our results will convince the JavaScript community to develop and adopt benchmarks that are more representative of real web applications.","cites":"54","conferencePercentile":"100"},{"venue":"WebApps","id":"b03ca73130f0755891bf009df643907bb90b8510","venue_1":"WebApps","year":"2012","title":"Gibraltar: Exposing Hardware Devices to Web Pages Using AJAX","authors":"Kaisen Lin, David Chu, James Mickens, Li Zhuang, Feng Zhao, Jian Qiu","author_ids":"8068724, 3180625, 1756726, 5681417, 5164095, 2944985","abstract":"Gibraltar is a new framework for exposing hardware devices to web pages. Gibraltar's fundamental insight is that Java-Script's AJAX facility can be used as a hardware access protocol. Instead of relying on the browser to mediate device interactions , Gibraltar sandboxes the browser and uses a small device server to handle hardware requests. The server uses native code to interact with devices, and it exports a standard web server interface on the localhost. To access hardware , web pages send device commands to the server using HTTP requests; the server returns hardware data via HTTP responses. Using a client-side JavaScript library, we build a simple yet powerful device API atop this HTTP transfer protocol. The API is particularly useful to developers of mobile web pages, since mobile platforms like cell phones have an increasingly wide array of sensors that, prior to Gibraltar, were only accessible via native code plugins or the limited, inconsistent APIs provided by HTML5. Our implementation of Gibraltar on Android shows that Gibraltar provides stronger security guarantees than HTML5; furthermore, it shows that HTTP is responsive enough to support interactive web pages that perform frequent hardware accesses. Gibraltar also supports an HTML5 compatibility layer that implements the HTML5 interface but provides Gibraltar's stronger security.","cites":"6","conferencePercentile":"77.77777778"},{"venue":"WebApps","id":"0b5a8c58d8290ed4e0f67ba1ff30916fee545870","venue_1":"WebApps","year":"2011","title":"Maverick: Providing Web Applications with Safe and Flexible Access to Local Devices","authors":"David W. Richardson, Steven D. Gribble","author_ids":"2601499, 1700451","abstract":"Web browsers do not yet provide Web programs with the same safe, convenient access to local devices that operating systems provide to native programs. As a result , Web programmers must either wait for the slowly evolving HTML standard to add support for the device classes they want to use, or they must use difficult to deploy browser plug-ins to add the access they need. This paper describes Maverick, a browser that provides Web applications with safe and flexible access to local devices. Maverick lets Web programmers implement USB device drivers and frameworks, like file systems or streaming video layers, using standard Web programming technologies such as HTML, JavaScript, or even code executed in a native client sandbox. These Web drivers and Web frameworks are downloaded dynamically from Web servers and executed by browsers alongside Web applications. Maverick provides Web drivers with protected access to the USB bus, and it provides Web drivers and frameworks with event-driven IPC channels to communicate with each other and with Web applications. We prototyped Maverick by modifying the Chrome Web browser and the Linux kernel. Using Maverick, we have implemented: several Web drivers, including a USB mass storage driver and a Webcam driver; several Web frameworks, including a FAT16 filesystem and a streaming video framework; and, several Web applications that exercise them. Our experiments show that Web drivers, frameworks, and applications are practical, easy to author , and have sufficient performance, even when implemented in JavaScript.","cites":"4","conferencePercentile":"18.18181818"},{"venue":"WebApps","id":"659d7db5345c7ef3b7255d7bdd16e42f1bd83cc4","venue_1":"WebApps","year":"2012","title":"Modeling and Reasoning about DOM Events","authors":"Benjamin S. Lerner, Matthew J. Carroll, Dan P. Kimmel, Hannah Quay-de la Vallee, Shriram Krishnamurthi","author_ids":"1705058, 7504065, 1981930, 2818061, 1724479","abstract":"Web applications are fundamentally reactive. Code in a web page runs in reaction to events, which are triggered either by external stimuli or by other events. The DOM, which specifies these behaviors, is therefore central to the behavior of web applications. We define the first formal model of event behavior in the DOM, with high fidelity to the DOM specification. Our model is concise and executable, and can therefore be used for testing and verification. We have applied it in several settings: to establish some intended meta-properties of the DOM, as an oracle for testing the behavior of browsers (where it found real errors), to demonstrate unwanted interactions between extensions and validate corrections to them, and to examine the impact of a web sandbox. The model composes easily with models of other web components, as a step toward full formal modeling of the web.","cites":"9","conferencePercentile":"94.44444444"},{"venue":"WebApps","id":"4c45bba162febdd8395b8c68ccc2678a3275ffd0","venue_1":"WebApps","year":"2010","title":"SVC: Selector-based View Composition for Web Frameworks","authors":"William P. Zeller, Edward W. Felten","author_ids":"3167090, 1752733","abstract":"We present Selector-based View Composition (SVC), a new programming style for web application development. Using SVC, a developer defines a web page as a series of transformations on an initial state. Each transformation consists of a selector (used to select parts of the page) and an action (used to modify content matched by the selector). SVC applies these transformations on either the client or the server to generate the complete web page. Developers gain two advantages by programming in this style. First, SVC can automatically add Ajax support to sites, allowing a developer to write interactive web applications without writing any JavaScript. Second, the developer can reason about the structure of the page and write code to exploit that structure, increasing the power and reducing the complexity of code that manipulates the page's content. We introduce SVC as a stateless, framework-agnostic development style. We also describe the design, implementation and evaluation of a prototype, consisting of a PHP extension using the WebKit browser engine [37] and a plugin to the popular PHP MVC framework Code Igniter [8]. To illustrate the general usefulness of SVC, we describe the implementation of three example applications consisting of common Ajax patterns. Finally, we describe the implementation of three post-processing filters and compare them to currently existing solutions.","cites":"4","conferencePercentile":"25"},{"venue":"WebApps","id":"30834a4353093fd33552386663cd6b5ab9336c90","venue_1":"WebApps","year":"2010","title":"SeerSuite: Developing a Scalable and Reliable Application Framework for Building Digital Libraries by Crawling the Web","authors":"Pradeep B. Teregowda, Isaac G. Councill, Juan Pablo Fernández Ramírez, Madian Khabsa, Shuyi Zheng, C. Lee Giles","author_ids":"1712873, 3291696, 2037978, 2072010, 3049801, 1749125","abstract":"SeerSuite is a framework for scientific and academic digital libraries and search engines built by crawling scientific and academic documents from the web with a focus on providing reliable, robust services. In addition to full text indexing, SeerSuite supports autonomous citation indexing and automatically links references in research articles to facilitate navigation, analysis and evaluation. SeerSuite enables access to extensive document, citation, and author metadata by automatically extracting , storing and indexing metadata. SeerSuite also supports MyCiteSeer, a personal portal that allows users to monitor documents, store user queries, build document portfolios, and interact with the document metadata. We describe the design of SeerSuite and the deployment and usage of CiteSeer x as an instance of SeerSuite.","cites":"14","conferencePercentile":"71.42857143"}]}