{"Workshop_on_Hot_Topics_in_Opera":[{"venue":"Workshop on Hot Topics in Operating Systems","id":"e80c0f45537b7261fa4f7392c4e10e64ad05f050","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1999","title":"How To Schedule Unlimited Memory Pinning of Untrusted Processes Or Provisional Ideas about Service-Neutrality","authors":"Jochen Liedtke, Volkmar Uhlig, Kevin Elphinstone, Trent Jaeger, Yoonho Park","author_ids":"1789481, 2488361, 1712212, 1699210, 1792526","abstract":"About This Paper You can read it as a paper that treats a concrete problem motivated in Section 1: How can we permit untrusted user processes to pin their virtual pages in memory most flexibly and as unlimited as possible? From this point of view, the paper presents a general solution that is theoretically and experimentally reasonably substantiated. However, you can also read the paper as an approach to solve the more general problem of how an existing system can be extended by new operations while preserving the original system's QoS properties. From this point of view, the paper is highly speculative. The presented principle of service-neutral operations can successfully solve the concrete problem of dynamic pinning. However, we still have no sound evidence that it is useful for a much broader class of problems. Nevertheless, we strongly suspect it. Traditionally, pinning memory is a privileged capability that is not available to normal user tasks but only to the OS kernel and some device drivers. Pinning is controlled by the facts that these components are statically known, that they are trusted, and that they have mostly restrictive policies minimizing pinning. Could applications benefit from more liberal pinning policies? There seem to be three basic classes of applications that can profit from pinning: (a) device drivers that use DMA, (b) real-time systems that rely on no-page-fault guarantees, and (c) database-like applications that perform drastically better when some application-specific pages are pinned for a shorter or longer time interval. In all cases, we see need for static and dynamic pinning. Static pinning is used for pinning driver or real-time code and data, certain buffers, etc. Basically, pages are pinned forever or at least for a very long time. The method is necessary to guarantee the basic functionality of some components. Static pinning can be controlled by traditional quota-based methods. Static pinning is not a topic of this paper. Dynamic pinning has two characteristic properties: pages are pinned for short periods only, and it is dynamically decided which and how many pages are pinned. We show four motivating examples: 1. For transmitting a file, the network system pins the file partially (or entirely) in memory for the transmission period. This enables zero-copy transmission, i.e. avoids copying data into network buffers, and thus increases the performance substantially. 2. For communicating data to a non-real-time component , a real-time application temporarily requests pinned memory. 3. …","cites":"8","conferencePercentile":"50"},{"venue":"Workshop on Hot Topics in Operating Systems","id":"6c9c2a307c0c4c1d36a2e8e1d5edbe84d4f21496","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1997","title":"Preventing Denial-of-Service Attacks on a µ-Kernel for WebOSes","authors":"Jochen Liedtke, Nayeem Islam, Trent Jaeger","author_ids":"1789481, 1731837, 1699210","abstract":"A goal of Worldwide Web operating systems (Web-OSes) is to enable clients to download executable content from servers connected to the Worldwide Web (WWW). This will make applications more easily available to clients, but some of these applications may be malicious. Thus, a WebOS must be able to control the downloaded content's behavior. In this paper, we examine a speciic type of malicious activity: denial-of-service attacks using legal system operations. A denial-of-service attack occurs when an attacker prevents other users from performing their authorized operations even when the attacker may not be able to perform such operations. Current systems either do little to prevent denial-of-service attacks or have a limited scope of prevention of such attacks. For a WebOS, however, the ability to prevent denial-of-service should be an integral part of the system. We are developing a WebOS using the L4-kernel as its substrate. In this paper, we evaluate L4 as a basis of a system that can prevent denial-of-service attacks. In particular, we identify the-kernel-related resources are subject to denial-of-service attacks and deene-kernel mechanisms to defend against such attacks. Our analysis demonstrates that system resource utilization can be managed by trusted, user-level servers to prevent denial-of-service attacks on such resources. 1 Motivations One of the results of the explosive growth of the Worldwide Web (web) is the popularization of down-loading executable content from the remote sites. However, downloading content from an arbitrary site increases the client's risk of executing malicious code. For example, clients can easily download Java applets using their favorite web browser. Although mechanisms for controlling the access rights of Java ap-plets exist, the ability of these mechanisms to prevent denial-of-service attacks is limited. For example , FlexxGuardd1] limits the number of windows that can be opened, processes that can be triggered, etc. for a Java applet. However, FlexxGuard can control only individual Java applets. It cannot take remedial actions should the combination of applets executing result in a denial-of-service. Denial-of-service attacks is characterized by an attacker preventing \\an authorized user from referring to or modifying information, even though the at-tacker] may not be able to refer to or modify the information.\" 6]. This deenition encompasses some types of denial-of-service attacks, which we call security malfunctions, in which an attacker implements an attack by changing the operations of the system. In our analysis, we focus on denial-of-service attacks that use the system's operations in an abusive manner. …","cites":"17","conferencePercentile":"64.28571429"},{"venue":"Workshop on Hot Topics in Operating Systems","id":"55e9c39f9d2b605513c51e6db97d01a7f163827d","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1999","title":"Hey, You Got Your Compiler in My Operating System!","authors":"Jon Howell, Mark H. Montague","author_ids":"2268930, 2750200","abstract":"Several operating systems projects revolve around moving functionality above or below the kernel \" red line \" to increase flexibility or performance. We describe how a general model of partial evaluation encompasses this trend. The operating systems community should not be content with a single interface between applications and the operating system, even if that interface allows extension below the red line; we contend that partial evaluation will be most effective when it is free of that arbitrary, static interface. Extending partial evaluation from the language level down to the hardware provides a consistent, global framework for application support.","cites":"0","conferencePercentile":"4.347826087"},{"venue":"Workshop on Hot Topics in Operating Systems","id":"8cd4d1e8049c5c106441f1cea61da3ae77ae140b","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1999","title":"The Case for Better Throughput Estimation","authors":"Brian D. Noble, Li Li, Atul Prakash","author_ids":"2055822, 1682059, 1704708","abstract":"A Web proxy must accurately predict network performance between itself and its servers and clients in order to make good distillation decisions. In this paper, we show that the current approaches to make such predictions — either assuming the proxy is well-connected to all servers or using past observations — are insufficient. We propose a new prediction method, estimation with uncertainty, that will play a crucial role in web proxies. This method can also be useful in domains such as distributed prefetching, distributed query planning, and cache replacement algorithms that take into account the cost of refetching evicted objects.","cites":"4","conferencePercentile":"28.26086957"},{"venue":"Workshop on Hot Topics in Operating Systems","id":"493a616985aac2901a3cc4a0c210f9fae23faaf5","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1999","title":"Caching Documents with Active Properties","authors":"Eyal de Lara, Karin Petersen, Douglas B. Terry, Anthony LaMarca, James D. Thornton, Michael Salisbury, Paul Dourish, W. Keith Edwards, John Lamping","author_ids":"1879216, 5186930, 1680763, 7871341, 2473625, 2634335, 1762952, 3023379, 2905809","abstract":"to reprint/republish this material for advertising or promotional purposes or for creating new collective works for resale or redistribution to servers or lists, or to reuse any copyrighted component of this work in other works must be obtained from the IEEE. Abstract Caching in the Placeless Documents system poses new challenges because users can attach active properties to documents. Active properties can modify the document's content as seen by a user. Thus, the caching mechanisms must take into account that a document's content not only depends on when the document was last modified, but also on the set of personal and universal properties attached to the document and the information on which these properties depend. Interestingly, active properties can be used to help caches manage their contents by notifying them of events that affect cache consistency, by providing caches with document-specific verifiers to further check on a document's consistency, and by returning information that can aid in decisions of which documents to cache.","cites":"2","conferencePercentile":"10.86956522"},{"venue":"Workshop on Hot Topics in Operating Systems","id":"b9455c75669f009d2f41e326ca87ac2acf187960","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1997","title":"What Synchronous Groupware Needs: Notification Services","authors":"Mark Day","author_ids":"1828533","abstract":"Synchronous groupware is the class of applications in which two or more people collaborate in what they perceive to be real time. Most previous efforts to deploy synchronous groupware have failed. I argue that: Ÿ synchronous groupware can often be deployed independently of system support for audio, video, or persistent storage; Ÿ deployment and maintenance of different synchronous groupware applications becomes more reasonable if those applications can share and reuse a common coordination infrastructure, called a notification service; and Ÿ the most likely way to achieve such sharing and reuse is by the definition of a common notification service protocol. At Lotus, we have designed and implemented such a protocol, called the Notification Service Transfer Protocol (NSTP). Our implementation, called PlaceHolder, has been available from our Web site since November 1996.","cites":"8","conferencePercentile":"21.42857143"},{"venue":"Workshop on Hot Topics in Operating Systems","id":"d4b991f2cefa95b282487a5c7a62d937df6affdb","venue_1":"Workshop on Hot Topics in Operating Systems","year":"1999","title":"Flexible Access Control using IPC Redirection","authors":"Trent Jaeger, Kevin Elphinstone, Jochen Liedtke, Vsevolod Panteleenko, Yoonho Park","author_ids":"1699210, 1712212, 1789481, 3151416, 1792526","abstract":"We present a mechanism for inter-process communication (IPC) redirection that enables efficient and flexible access control for micro-kernel systems. In such systems, services are implemented at user-level, so IPC is the only means of communication between them. Thus, the system must be able to mediate IPCs to enforce its access control policy. Such mediation must enable enforcement of security policy with as little performance overhead as possible, but current mechanisms either: (1) place significant access control functionality in the kernel which increases IPC cost or (2) are static and require more IPCs than necessary to enforce access control. We define an IPC redirection mechanism that makes two improvements: (1) it removes the management of redirection policy from the kernel, so access control enforcement can be implemented outside the kernel and (2) it separates the notion of who controls the redirection policy from the redirections themselves, so redirections can be configured arbitrarily and dynamically. In this paper , we define our redirection mechanism, demonstrate its use, and examine possible, efficient implementations.","cites":"21","conferencePercentile":"65.2173913"}]}