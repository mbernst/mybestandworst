{"X10_12.csv":[{"venue":"X10 '12","id":"3616823b987712a5af712dd944995c2917a4002b","venue_1":"X10 '12","year":"2012","title":"Distributed garbage collection for managed X10","authors":"Kiyokuni Kawachiya, Mikio Takeuchi, Salikh Zakirov, Tamiya Onodera","author_ids":"1697424, 2804738, 3352216, 1698545","abstract":"X10 is a programming language that incorporates distributed processing functions. The execution model of X10 is called \"APGAS\", where each object belongs to a specific <i>place</i> (an abstraction of a shared-memory computer), but can be <i>remotely referenced</i> from other places using a mechanism named GlobalRef. This means that a remotely-referenced object must not be collected as garbage even if there is no local reference to it.\n There is an implementation of X10 named \"Managed X10\", which uses multiple Java virtual machines (JVMs) to run an X10 application. In a Managed X10 environment, X10 objects are represented by Java objects, and unneeded objects are collected by the GC in the JVM. Each place is implemented as an individual JVM, so distributed processing is possible by using multiple JVMs on multiple computers. However, in the early implementation of Managed X10, objects that were ever remotely referenced through GlobalRef were registered in a management table and would never be collected. Therefore, if an application uses GlobalRefs periodically, its heap area is consumed by uncollectable objects and an OutOfMemoryError condition may eventually occur.\n To solve this problem, we developed a distributed GC for Managed X10. The core part of this GC is provided by an internal data structure called the \"Globalized Object Tracker\" (GOT), which is prepared for each remotely-referenced (globalized) object. GOT tracks the number of remote references to the object and handles the mapping between the object and its ID. When all remote references are removed, the distributed GC makes the object collectable by the local JVM GC.\n This paper first introduces the distributed execution model of X10 and the mechanism of GlobalRef, then explains how the distributed GC is implemented in Managed X10. The implementation does not modify the JVM, so it is highly portable. Through various evaluation experiments, we show that the remotely-referenced objects are correctly collected and there is almost no performance degradation in the proposed distributed GC.","cites":"5","conferencePercentile":"66.66666667"},{"venue":"X10 '12","id":"458c25704443b229ba76cdb36f729e012717a625","venue_1":"X10 '12","year":"2012","title":"Fast method dispatch and effective use of primitives for reified generics in managed X10","authors":"Mikio Takeuchi, Salikh Zakirov, Kiyokuni Kawachiya, Tamiya Onodera","author_ids":"2804738, 3352216, 1697424, 1698545","abstract":"Two new techniques for improving performance of reified generics without specializing types are presented. With these techniques, the cost of method dispatch is reduced by 95% from the regular self dispatching based implementation, and the cost of returning primitive value is reduced by 15% from the regular boxing based implementation. These techniques are useful to implement reified generics in Java and other JVM languages.","cites":"3","conferencePercentile":"33.33333333"}]}