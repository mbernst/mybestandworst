{"XPAgile_Universe.csv":[{"venue":"XP/Agile Universe","id":"a5478952c67d6e757b4c0473b3996d670e287db1","venue_1":"XP/Agile Universe","year":"2003","title":"Virtual Teaming: Experiments and Experiences with Distributed Pair Programming","authors":"P. David Stotts, Laurie A. Williams, Nachiappan Nagappan, Prashant Baheti, Dennis Jen, Anne Jackson","author_ids":"2158857, 1725469, 1693689, 2181130, 2550879, 1857984","abstract":"Pair programming is a practice in which two programmers work together at one computer, collaborating on the same design, algorithm, code or test. Previous studies have shown that pair programmers produce higher quality code in essentially the same amount of time as solo programmers. Additional benefits include increased job satisfaction, improved team communication, and efficient tacit knowledge sharing. However, it may not always be possible for all team members to be collocated due to the rise in teleworking and geographically distributed teams. This paper analyzes the results of two distributed pair programming case studies done at UNC Chapel Hill and at NC State University. Participants used readily available off-the-shelf applications for collaborative software development. The results indicate that software development collaboratively \" over the wire \" is feasible, effective, and pleasant for the participants; distributed development is better done as synchronous pairs than as individuals who integrate; and distributed pairs maintain many of the advantages of collocated pairs.","cites":"40","conferencePercentile":"100"},{"venue":"XP/Agile Universe","id":"47352918b91437cbe65df9f812d98be9ff180b96","venue_1":"XP/Agile Universe","year":"2002","title":"Perceptions of Agile Practices: A Student Survey","authors":"Grigori Melnik, Frank Maurer","author_ids":"1702764, 1736996","abstract":"The paper reports on the results of a recent study on student perceptions on agile practices. The study involved forty-five students enrolled in three different academic programs (Diploma, Bachelor's and Master's) in two institutions to determine their perceptions of the use of extreme programming practices in doing their design and coding assignments. Overwhelmingly, students' experiences were positive and their opinions indicate the preference to continue to use the practices if allowed.","cites":"20","conferencePercentile":"58.33333333"},{"venue":"XP/Agile Universe","id":"249366589ff47dbf317c15eca9d311af06e43902","venue_1":"XP/Agile Universe","year":"2002","title":"Supporting Adaptable Methodologies to Meet Evolving Project Needs","authors":"Scott Henninger, Aditya Ivaturi, Krishna Nuli, Ashok Thirunavukkaras","author_ids":"1907203, 2434209, 2111970, 2243540","abstract":"While most agile methodologies assume that change is inevitable, current approaches have adopted the strategy of defining practices and activities that are general enough to be adapted to many project settings. These methodologies have the ability to address variance and adaptability within the processes, but are unable to adopt different methodologies to meet the evolving needs of projects as they progress through their lifecycles, or change to meet new business or user conditions. For example, a project may begin with a Scrum-based process, but require some XP processes or even heavyweight processes later in the lifecycle. Agile methodologies should be able to react to these changes with appropriate practices and processes that fit project needs at any point in time. In this paper, we describe a methodology generator, a tool that can create hybrid approaches to software development spanning from the most simple to the agile to the heavyweight, depending on project needs. A rule based system is combined with an experience-based feedback mechanism to define the conditions under which a given methodology, process, or activity is applicable to project needs. Deviations from the defined process are freely allowed, but the deviations are captured by the tool so it can be analyzed for process improvements that can help software development organizations become more adaptive to changes in business and technology conditions. 1 Finding The Right Methodology for the Job While often confused with high-speed software development in \" Internet time \" [7], Development Method (DSDM) [27] and others have focused on the need for software development methodologies that can adapt to changing requirements and fast changing business needs. A critical, but neglected, issue these methodologies face is the need to balance the desire for innovation with knowledge of past experiences and best practices. This tension between past knowledge and creating new knowledge is particularly acute in the software industry, which involves the development of a highly variable product that dictates the need for continuous process adjustments. The rise of agile methodologies can partly be attributed to a backlash against \" heavyweight \" methodologies that can overemphasize process, documentation, and stability over software development. These values can be dysfunctional when requirements are volatile [13] or business conditions change. The alternative is to embrace change [1, 16, 17] and refocus on ensuring that the right product is built, not just that the product is built to specification [9]. While these views are …","cites":"13","conferencePercentile":"33.33333333"},{"venue":"XP/Agile Universe","id":"448b47e527bc87fab860c410dff7124d8cc1cd73","venue_1":"XP/Agile Universe","year":"2004","title":"Suitability of FIT User Acceptance Tests for Specifying Functional Requirements: Developer Perspective","authors":"Grigori Melnik, Kris Read, Frank Maurer","author_ids":"1702764, 2749643, 1736996","abstract":"The paper outlines an experiment conducted in two different academic environments, in which FIT tests were used as a functional requirements specification. Common challenges for functional requirements specifications are identified, and a comparison is made between how well prose and FIT user acceptance tests are suited to overcoming these challenges from the developer's perspective. Experimental data and participant feedback are examined to evaluate whether developers can use requirements in the form of FIT tests to create a design and implementation.","cites":"15","conferencePercentile":"66.66666667"},{"venue":"XP/Agile Universe","id":"95ba7499b4c397fd2a0edc9bbbbcd3bd4e08928f","venue_1":"XP/Agile Universe","year":"2003","title":"Introducing Agile Methods in Learning Environments: Lessons Learned","authors":"Grigori Melnik, Frank Maurer","author_ids":"1702764, 1736996","abstract":"This paper describes the experiences of introducing agile methods in four different academic programs (Diploma, Applied Bachelor's, Bachelor's and Master's) in two institutions during two academic years. It contains suggestions and techniques for bringing agile methods into curriculum. Based on overwhelmingly positive students' experiences this report should encourage other academics that are considering introducing agile methods in their software engineering courses.","cites":"15","conferencePercentile":"72.22222222"},{"venue":"XP/Agile Universe","id":"32684cf9cccca466df08e3a3d507e1a5bef4edd5","venue_1":"XP/Agile Universe","year":"2003","title":"Pair Learning: With an Eye Toward Future Success","authors":"Nachiappan Nagappan, Laurie A. Williams, Eric Wiebe, Carol Miller, Suzanne Balik, Miriam Ferzli, Julie Petlick","author_ids":"1693689, 1725469, 4989680, 5756356, 2206061, 2751173, 2556824","abstract":"Pair programming is a practice in which two programmers work collaboratively at one computer on the same design, algorithm, or code. Prior research indicates that pair programmers produce higher quality code in essentially half the time taken by solo programmers. Pair programming is becoming increasingly popular in industry and in university curricula. An experiment was run at North Carolina State University over a period of one and a half years to assess the efficacy of pair programming as an alternative educational technique in an introductory programming course. We found that the retention rate of the students in the introductory programming courses is equal to or better than that of the students in the solo programming courses. Most students show a positive attitude towards collaborative programming, and students in paired classes continue to be successful in subsequent programming classes that require solo programming. Pair programming also leads to a reduced workload for the course staff in terms of grading, questions answered and teaching effort.","cites":"18","conferencePercentile":"88.88888889"},{"venue":"XP/Agile Universe","id":"96d66c797b4d18434f56ef9bdbb951ace40b723a","venue_1":"XP/Agile Universe","year":"2002","title":"An Informal Formal Method for Systematic JUnit Test Case Generation","authors":"P. David Stotts, Mark Lindsey, Angus Antley","author_ids":"2158857, 8058074, 1705895","abstract":"The JUnit testing tool is widely used to support the central XP concept of \" test first \" software development. While JUnit provides Java classes for expressing test cases and test suites, it does not provide or proscribe per se any guidelines for deciding what test cases are good ones for any particular class. We have developed a method for systematically creating complete and consistent test classes for JUnit. Called JAX (for Junit Axioms), the method is based on Guttag's algebraic specification of abstract data types. We demonstrate an informal use of ADT semantics for guiding JUnit test method generation; the programmer uses no formal notation other than Java, and the procedure meshes with XP test-as-design principles. Preliminary experiments show that informal JAX-based testing finds more errors than an ad hoc form of JUnit testing. 1 Motivation and background Regression testing has long been recognized as necessary for having confidence in the correctness of evolving software. Programmers generally do not practice thorough tool-supported regression testing, however, unless they work within a significant industrial framework. JUnit [1,2,3] was developed to support the \" test first \" principle of the XP development process [4]; it has had the side effect of bringing the benefits of regression testing to the average programmer, including independent developers and students. JUnit is small, free, easy to learn and use, and has obtained a large user base in the brief time since it's introduction in the XP community. Given this audience, we will not go into any detail about its structure and usage. JUnit and its supporting documentation are available at http://www.junit.org. The basic JUnit testing methodology is simple and effective. However, it still leaves software developers to decide if enough test methods have been written to exercise all the features of their code thoroughly. The documentation supporting JUnit does not prescribe or suggest any systematic methodology for creating complete and consistent test suites. Instead it is designed to provide automated bookkeeping, accumulation, and execution support for the manner in which a programmer is already accustomed to developing test suites. We have developed and experimented with a systematic test suite generation method we call JAX (for Junit Axioms), based on Guttag's algebraic semantics of Abstract Data Types (ADTs) [5,6,7]. Following the JAX method leads to JUnit test suites that completely cover the possible behaviors of a Java class. Our approach is","cites":"37","conferencePercentile":"83.33333333"},{"venue":"XP/Agile Universe","id":"4de2dde7e0380bce3ff36d24c236430faf2c2554","venue_1":"XP/Agile Universe","year":"2002","title":"Exploring the Efficacy of Distributed Pair Programming","authors":"Prashant Baheti, Edward F. Gehringer, P. David Stotts","author_ids":"2181130, 1731813, 2158857","abstract":"Pair programming is one of the twelve practices of Extreme Programming (XP) [1]. Pair programming is usually performed by programmers who are collocated—working in front of the same monitor. But the inevitability of distributed development of software gives rise to important questions: How effective is pair programming if the pairs are not physically next to each other? What if the programmers are geographically distributed? An experiment was conducted at North Carolina State University to compare different working arrangements of student teams developing object-oriented software. Teams were both collocated and in distributed environments; some teams practiced pair programming while others did not. In particular, we compared the software developed by virtual teams using distributed pair programming against collocated teams using pair programming and against virtual teams that did not employ distributed pair programming. The results of the experiment indicate that it is feasible to develop software using distributed pair programming, and that the resulting software is comparable to software developed in collocated or virtual teams (without pair programming) in terms of productivity and quality.","cites":"56","conferencePercentile":"91.66666667"},{"venue":"XP/Agile Universe","id":"72e7bfe48b9767ca37f14ea9f8d2ee6232d3370f","venue_1":"XP/Agile Universe","year":"2002","title":"Supporting Distributed Extreme Programming","authors":"Frank Maurer","author_ids":"1736996","abstract":"Extreme programming (XP) is arguably improving the productivity of small, co-located software development teams. In this paper, we described an approach that tries to overcome the XP constraint of co-location by introducing a process-support environment (called MILOS for Agile Software Engineering-MILOS ASE) that helps software development teams to maintain XP practices in a distributed setting. MILOS ASE supports project coordination using the planning game, user stories, information routing, team communication, and pair programming .","cites":"17","conferencePercentile":"50"},{"venue":"XP/Agile Universe","id":"5257aa9f102324624aa0a26a9add04575e7598b5","venue_1":"XP/Agile Universe","year":"2003","title":"Issues in Scaling Agile Using an Architecture-Centric Approach: A Tool-Based Solution","authors":"Kris Read, Frank Maurer","author_ids":"2749643, 1736996","abstract":"Agile software development processes are best applied to small teams on small to medium sized projects. Scaling agile methodologies is desired in order to bring the benefits of agile to larger, more complex projects. One way to scale agile methods is via an architecture-centric approach, in which a project is divided into smaller modules on which sub teams can use agile effectively. However, a problem with architecture-centric modifications to agile methods is the introduction of non-agile elements, for instance up-front design and integration difficulties. These issues are discussed and a tool-based solution is presented facilitating the adoption of the architecture-centric agile approach. 1 Introduction Martin Fowler likes to say, \" Scaling agile methods is the last thing you want to do. 1 \" At the Canadian Workshop on Scaling Agile Processes this generated quite a stir, but it turns out that he meant it literally. The idea is that one should examine every other alternative first, and consider scaling as a last resort. Nonetheless there is a need to scale agile methods. Large projects are out there, projects for which a small team is not ideally suited. If a team needs to deliver a lot of functionality but also has a lot of time, the team size can be quite small. Likewise the team can be small if it has not much time but can reduce the scope of the project. However, to deliver a lot of functionality in a short amount of time, the business solution is to add more people. Scaling a software development project would traditionally be accomplished through heavyweight processes and stacks of documentation. But it is desirable to reduce the project overhead in order to maximize productivity, and so the question becomes \" How do we scale Agile Methods? \" To improve the scalability of agile software processes, one solution is to follow a divide and conquer strategy based on architecture. An architecture-centric strategy is nothing new – Ken Schwaber advocates using the first iteration of an agile project to have a smaller team define the project architecture, and then proposes multi-team coordination through a \" Scrum of Scrums \" for the remainder of iterations. If the project is initially broken down into smaller modules, each module can be built using an agile approach. This plan enables the application of proven agile methodologies using small cohesive teams at a module level. Following this strategy may …","cites":"4","conferencePercentile":"33.33333333"}]}